## 数据与运算

### 数据宽度

数学上：0 ~ 无穷大

计算机：内存有限！给数据增加数据宽度来限制

C 和 C++ 、Java 都需要定义数据的类型，计算机底层需要我们给这些数据定义宽度

位：0，1

字节：0-0xFF

字：0-0xFFFF

双字：0-0xFFFFFFFF

在计算机中，每一个数据都需要给它定义类型。给它定义宽度，在内存中的宽度



### 有符号数和无符号数

数据都是有宽度的，每个数据代表什么意思呢？

```shell
0 1 0 1 0 1 0 1
```

#### 规则

二进制解码有规则：**无符号数规则、有符号数规则** 

##### 无符号数规则

```shell
1 0 0 1  1 0 1 0  十六进制：0x9A, 十进制：154
```

##### 有符号规则

最高位是符号位：1(负数)    0(正数)

```shell
1 0 0 1  1 0 1 0
```



### 原码反码补码

##### 有符号的编码规则

**原码** ：最高位符号位，对其他的位进行本身绝对值即可

**反码** ：

- 正数：反码和原码相同
- 负数：符号位一定是1，其余位对原码取反

**补码** ：

- 正数：补码和原码相同
- 负数：符号位一定是1，反码加1

```shell
# 限定下列数都为8位
# 如果是正数，那都是一样的
1
# 原码 0000 0001
# 反码 0000 0001
# 补码 0000 0001

# 如果是负数
-1
# 原码 1000 0001
# 反码 1111 1110
# 补码 1111 1111
-7
# 原码 1000 0111
# 反码 1111 1000
# 补码 1111 1001
```

如果看到一个数字，二进制的，需要了解他是有符号数还是无符号数



### 位运算

2*8 最高效的计算方式

很多底层的调试器，需要通过位来判断CPU的状态



#### 与运算（and &）

**两个都为1，结果才为1** 

```shell
1011 0001	
and			# 与运算
1101 1000
---------
1001 0000
```

#### 或运算（or  |）

**其中一个为1，结果就为1** 

```shell
1011 0001	
or			# 或运算
1101 1000
---------
1111 1001
```

#### 异或运算（xor ^）

**两个不同则为1** 

```shell
1011 0001	
xor			# 异或运算
1101 1000
---------
0110 1001
```

#### 非运算（单目运算符  not  ~）

0变1，1变0，取反

```shell
1101 1000
not			# 非运算
---------
0010 0111
```

#### 位运算（移动位）

```shell
0000 0001		1
0000 0010		2
0000 0100		4
0000 1000		8
```

**左移（shi <<）**

```shell
0000 0001		# 所有二进制位都向左移动若干位，高位丢弃，地位补零
shi 1
---------
0000 0010
```

**右移（shr >>）** 

```shell
0000 0010		# 所有二进制位都向右移动若干位，高位补零，地位丢弃
shr 1
---------
0000 0001
```



### 位运算实现加减乘除

计算机只认识0 1

基本数学是建立在 **加减乘除** 上的，而 **加减乘除** 本质上还是 **加** 

**4+5？** 

```shell
# 计算机是怎么操作的
0000 0100
0000 0101
---------		# 加法，但是计算机是不会加法的
0000 1001

### 计算机实现原理

# 第一步，异或，如果不考虑进位，异或就可以出结果
0000 0100
xor
0000 0101
---------
0000 0001

# 第二步，与运算（判断进位，如果与运算结果为0，则没有进位，没有进位则结束运算）
0000 0100
and
0000 0101
---------
0000 0100

# 第三步，将与运算的结果，左移一位
0000 0100
shi 1
---------
0000 1000

# 第四步，将与运算结果和异或运算结果进行异或运算
0000 0001
xor
0000 1000
---------
0000 1001

# 第五步，进行与运算验证，看是否进位
0000 0001
and
0000 1000
---------
0000 0000
# 结果为0，完成验证，通过，结束，结果为0000 1001
```

**4-5?** 

```shell
# 计算机是怎么操作的
4+(-5)
0000 0100
1111 1011		# 0000 0101为5，那-5就为5的补码，即取反+1
---------		# 减法(加负数)，但是计算机是不会减法的
1111 1111

### 计算机实现原理

# 第一步，异或，如果不考虑进位，异或就可以出结果
0000 0100
xor
1111 1011
---------
1111 1111

# 第二步，与运算（判断进位，如果与运算结果为0，则没有进位）
0000 0100
and
1111 1011
---------
0000 0000
# 没有进位，结束运算，结果为 1111 1111
```

乘法：x*y，就是y个x相加，还是加法

除法：x/y，就是x能减去多少个y，本质是减法，最终还是加法

**计算机只会做加法！** 